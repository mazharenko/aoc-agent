using System.Text;
using mazharenko.AoCAgent.Generator.Mics;
using mazharenko.AoCAgent.Generator.Sources;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace mazharenko.AoCAgent.Generator;

internal partial class DaysGenerator
{
	private static void GenerateYear(SourceProductionContext productionContext, YearSource yearSource)
	{
		productionContext.CancellationToken.ThrowIfCancellationRequested();
		var newClass =
			ClassDeclaration(yearSource.YearClass.Name)
				.AddAttributeLists(CodeGeneratedAttribute.AsSyntax)
				.AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.PartialKeyword))
				.AddBaseListTypes(
					SimpleBaseType(IdentifierName("YearBase"))
				).AddMembers(
					ConstructorDeclaration(yearSource.YearClass.Name)
						.AddModifiers(Token(SyntaxKind.PublicKeyword))
						.WithBody(
							Block(yearSource.DaySources.SelectMany(AddDaySyntax))
						),
					PropertyDeclaration(PredefinedType(Token(SyntaxKind.IntKeyword)), Identifier("Year"))
						.WithExpressionBody(ArrowExpressionClause(LiteralExpression(SyntaxKind.NumericLiteralExpression,
							Literal(yearSource.YearClass.Num))))
						.WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
						.AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.OverrideKeyword))
				);

		var newRoot = CompilationUnit()
			.AddMembers(
				yearSource.YearClass.Namespace is null
					? newClass
					: FileScopedNamespaceDeclaration(ParseName(yearSource.YearClass.Namespace))
						.AddMembers(newClass)
			).AddDefaultUsings()
			.WithLeadingTrivia(
				AutoGeneratedComment,
				RestoreNullable
			);
		productionContext.AddSource($"{yearSource.YearClass.Name}.g.cs", SourceText.From(
			newRoot.NormalizeWhitespace(indentation: "\t").ToFullString(),
			Encoding.UTF8
		));
	}

	private static LocalDeclarationStatementSyntax Declare(string identifier, ExpressionSyntax valueClause)
	{
		return LocalDeclarationStatement(
			VariableDeclaration(
				IdentifierName("var")
			).WithVariables(
				SingletonSeparatedList(
					VariableDeclarator(identifier)
						.WithInitializer(
							EqualsValueClause(valueClause)
						)
				)
			));
	}

	private static IEnumerable<StatementSyntax> AddPartSyntax(DaySource day, int partNum, ClassDeclarationSyntax part, INamedTypeSymbol partType)
	{
		yield return Declare($"day{day.Number}part{partNum}",
			ObjectCreationExpression(ParseTypeName(partType.ToDisplayString()))
				.WithArgumentList(ArgumentList())
		);
		var dayNumExpression = InvocationExpression(
			MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("DayNum"), IdentifierName("Create"))
		).WithArgumentList(
			ArgumentList(SingletonSeparatedList(
				Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(day.Number))))
			));
		var partNumExpression = InvocationExpression(
			MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("PartNum"), IdentifierName("Create"))
		).WithArgumentList(
			ArgumentList(SingletonSeparatedList(
				Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(partNum))))
			));
		yield return Declare($"day{day.Number}RunnerPart{partNum}",
			ObjectCreationExpression(IdentifierName("RunnerPart"))
				.WithArgumentList(ArgumentList(
					SeparatedList(new ExpressionSyntax[]
					{
						dayNumExpression,
						partNumExpression,
						IdentifierName($"day{day.Number}part{partNum}"),
					}.Select(Argument))
				))
		);
		yield return ExpressionStatement(
			InvocationExpression(
				MemberAccessExpression(
					SyntaxKind.SimpleMemberAccessExpression,
					IdentifierName("Parts"),
					IdentifierName("Add")
				)
			).WithArgumentList(
				ArgumentList(SingletonSeparatedList(
					Argument(IdentifierName($"day{day.Number}RunnerPart{partNum}") ))
				)
			)
		);
	}

	private static IEnumerable<StatementSyntax> AddDaySyntax(DaySource day)
	{
		foreach (var part in AddPartSyntax(day, 1, day.Part1.PartClass, day.Part1.PartType))
			yield return part;
		foreach (var part in AddPartSyntax(day, 2, day.Part2.PartClass, day.Part2.PartType))
			yield return part;
	}
}